<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<title>Windows</title>
</head><body><b>Check user and groups<br/>
</b>whoami<br/>
net user &lt;username&gt;<b><br/>
</b><b><br/>
Have a quick look a round user's desktop<br/>
and other common locations<br/>
<br/>
Run winPEAS with fast, searchfast, and cmd options<br/>
<br/>
Run Seatbelt<br/>
<br/>
<br/>
Strategy --&gt; spend more time in enumeration and avoid rabbit holes<br/>
<br/>
<br/>
Try things that don't have may steps first<br/>
--&gt; Registry exploit, services, etc.<br/>
<br/>
Look at admin process, enum version and search for exploit<br/>
<br/>
check for internal ports that might be able to forward to the attacking machine<br/>
<br/>
<br/>
<br/>
re-read enum<br/>
<br/>
<br/>
Think about kernel exploits<br/>
<br/>
Search file<br/>
<br/>
</b>dir "\*&lt;filename&gt;*" /s<b><br/>
</b><b><br/>
<br/>
Grep all password<br/>
<br/>
<br/>
</b>type * | findstr password<b><br/>
</b><b><br/>
<br/>
<br/>
Unquoted Services Paths<br/>
</b><br/>
<br/>
Get-CIMInstance -class Win32_Service -Property Name, DisplayName, PathName, StartMode | Where {$_.StartMode -eq "Auto" -and $_.PathName -notlike "C:\Windows*" -and $_.PathName -notlike '"*'} | select PathName,DisplayName,Name<br/>
<br/>
<br/>
<br/>
<b>Check Running Services</b><br/>
<br/>
Get-Services |where {$_.Status -eq "Running"}<br/>
<br/>
<br/>
<b>Have Password in Secure String?<br/>
<br/>
</b>$pass = "........." |convertto-securestring<br/>
<br/>
$user = "&lt;domain&gt;\&lt;username&gt;"<br/>
$cred = New-Object System.Management.Automation.PSCredential($user, $pass)<br/>
$cred.GetNetworkCredential() | fl<br/>
<br/>
<img src="image.png" /><br/>
<br/>
or goto [<b>Active Directory</b>] &gt; [<b>Powershell</b>] &gt; [<b>Login with another user in AD</b>]</body></html>